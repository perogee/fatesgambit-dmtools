<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gambit System</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Constants & Helpers ---

        const SUITS = [
            { symbol: 'â™ ', color: 'black', type: 'spades' },
            { symbol: 'â™£', color: 'black', type: 'clubs' },
            { symbol: 'â™¥', color: 'red', type: 'hearts' },
            { symbol: 'â™¦', color: 'red', type: 'diamonds' }
        ];

        const RANKS = [
            { label: 'A', value: 1, type: 'Ace' },
            { label: '2', value: 2, type: 'Number' },
            { label: '3', value: 3, type: 'Number' },
            { label: '4', value: 4, type: 'Number' },
            { label: '5', value: 5, type: 'Number' },
            { label: '6', value: 6, type: 'Number' },
            { label: '7', value: 7, type: 'Number' },
            { label: '8', value: 8, type: 'Number' },
            { label: '9', value: 9, type: 'Number' },
            { label: '10', value: 10, type: 'Number' },
            { label: 'J', value: 11, type: 'Jack' },
            { label: 'Q', value: 12, type: 'Royalty' },
            { label: 'K', value: 13, type: 'Royalty' }
        ];

        const createDeck = () => {
            let deck = [];
            let id = 0;
            SUITS.forEach(suit => {
                RANKS.forEach(rank => {
                    deck.push({
                        id: `card-${id++}`,
                        suit: suit.symbol,
                        color: suit.color,
                        label: rank.label,
                        type: rank.type,
                        baseValue: rank.value,
                        pointValue: suit.color === 'black' ? rank.value : -rank.value
                    });
                });
            });
            return deck;
        };

        const shuffleDeck = (deck) => {
            let newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        };

        const uniqueDeck = (cards) => {
            const seen = new Set();
            return cards.filter(c => {
                if (seen.has(c.id)) return false;
                seen.add(c.id);
                return true;
            });
        };

        const calculateHandScore = (cards, jackValues = {}, isSystem = false) => {
            let hasBlackRoyalty = false;
            let hasRedRoyalty = false;
            let score = 0;

            cards.forEach(card => {
                if (card.type === 'Royalty') {
                    if (card.color === 'black') hasBlackRoyalty = true;
                    if (card.color === 'red') hasRedRoyalty = true;
                } else if (card.type === 'Jack') {
                    if (isSystem) {
                        // System Optimal Strategy
                        score += (card.color === 'black' ? 5 : -1);
                    } else {
                        const val = jackValues[card.id] !== undefined ? jackValues[card.id] : card.pointValue;
                        score += val;
                    }
                } else {
                    score += card.pointValue;
                }
            });

            return { score, hasBlackRoyalty, hasRedRoyalty };
        };

        // --- Styles ---
        const styles = `
            .card-font { font-family: 'Crimson Text', serif; }
            .wood-texture {
                background-color: #3e2723;
                background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M20 20c0-11.05 8.95-20 20-20s20 8.95 20 20-8.95 20-20 20-20-8.95-20-20zm0 0c0-11.05-8.95-20-20-20S0 8.95 0 20s8.95 20 20 20 20-8.95 20-20z' fill='%235d4037' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
            }
            .felt-texture {
                background-color: #2e7d32;
                background-image: radial-gradient(#388e3c 15%, transparent 16%), radial-gradient(#388e3c 15%, transparent 16%);
                background-size: 20px 20px;
                background-position: 0 0, 10px 10px;
            }
            .scrollbar-hide::-webkit-scrollbar { display: none; }
            .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        `;

        // --- Modals ---

        const Modal = ({ children }) => (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                <div className="bg-slate-800 border border-slate-600 rounded-xl p-6 shadow-2xl max-w-md w-full animate-in zoom-in duration-200">
                    {children}
                </div>
            </div>
        );

        // --- Components ---

        const Card = ({ card, isSelected, isLocked, onClick, isFaceUp = true, isSmall = false, canSelect = true, customValue }) => {
            if (!card) return <div className={`border-2 border-dashed border-white/20 rounded-lg ${isSmall ? 'w-16 h-24' : 'w-24 h-36'}`}></div>;

            if (!isFaceUp) {
                return (
                    <div onClick={canSelect ? onClick : undefined} className={`relative ${isSmall ? 'w-16 h-24' : 'w-24 h-36'} ${isSelected ? 'ring-4 ring-red-500 transform -translate-y-4' : ''} bg-blue-800 rounded-lg border-2 border-white shadow-md flex items-center justify-center transition-all duration-200`}>
                        <div className="w-full h-full border-2 border-blue-600 rounded-md bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4IiBoZWlnaHQ9IjgiPgo8cmVjdCB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMWU0MGFmIj48L3JlY3Q+CjxwYXRoIGQ9Ik0wIDBMOCA4Wk04IDBMMCA4WiIgc3Ryb2tlPSIjMWQ0ZWQ4IiBzdHJva2Utd2lkdGg9IjEiPjwvcGF0aD4KPC9zdmc+')] opacity-50"></div>
                    </div>
                );
            }

            return (
                <div 
                    onClick={onClick}
                    className={`
                        relative ${isSmall ? 'w-16 h-24 text-base' : 'w-24 h-36 text-2xl'} 
                        rounded-lg shadow-lg cursor-pointer transition-all duration-200 transform select-none
                        flex flex-col items-center justify-between p-2 card-font bg-white
                        ${isSelected ? 'ring-4 ring-yellow-400 -translate-y-4 shadow-yellow-400/50' : 'hover:-translate-y-1 hover:shadow-xl'}
                        ${isLocked ? 'ring-4 ring-orange-500 bg-orange-50' : ''}
                        ${card.color === 'red' ? 'text-red-600' : 'text-slate-900'}
                    `}
                >
                    <div className="self-start leading-none font-bold">{card.label}</div>
                    <div className="text-4xl">{card.suit}</div>
                    <div className="self-end leading-none font-bold rotate-180">{card.label}</div>
                    {isLocked && <div className="absolute inset-0 flex items-center justify-center pointer-events-none opacity-20 text-4xl">ðŸ”’</div>}
                    {customValue !== undefined && <div className="absolute top-1 right-1 text-xs bg-black/80 text-white px-1 rounded">{customValue > 0 ? '+' : ''}{customValue}</div>}
                </div>
            );
        };

        const DeckPile = ({ count, label, onClick, showShuffle }) => {
            return (
                <div className="flex flex-col items-center gap-2">
                    <div className="relative w-28 h-40" onClick={onClick}>
                        {count > 0 && Array.from({ length: Math.min(count, 5) }).map((_, i) => (
                            <div key={i} className="absolute w-24 h-36 bg-blue-800 rounded-lg border border-white shadow-md" style={{ top: `${i * 2}px`, left: `${i * 2}px`, zIndex: i }}>
                                <div className="w-full h-full rounded-md bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4IiBoZWlnaHQ9IjgiPgo8cmVjdCB3aWR0aD0iOCIgaGVpZ2h0PSI4IiBmaWxsPSIjMWU0MGFmIj48L3JlY3Q+CjxwYXRoIGQ9Ik0wIDBMOCA4Wk04IDBMMCA4WiIgc3Ryb2tlPSIjMWQ0ZWQ4IiBzdHJva2Utd2lkdGg9IjEiPjwvcGF0aD4KPC9zdmc+')] opacity-30"></div>
                            </div>
                        ))}
                        {count === 0 && (
                            <div className="absolute top-0 left-0 w-24 h-36 border-2 border-dashed border-white/30 rounded-lg flex items-center justify-center"><span className="text-white/30 text-sm">Empty</span></div>
                        )}
                        <div className="absolute bottom-2 left-1/2 transform -translate-x-1/2 text-white font-bold text-sm bg-black/60 px-2 py-1 rounded shadow-lg z-20 whitespace-nowrap backdrop-blur-sm">
                            {count} Cards
                        </div>
                    </div>
                    <div className="flex flex-col items-center">
                        <h3 className="text-white font-bold tracking-wider text-sm uppercase mt-1">{label}</h3>
                        {showShuffle && count > 0 && <button onClick={(e) => { e.stopPropagation(); onClick(); }} className="mt-1 px-2 py-0.5 text-xs bg-blue-600 hover:bg-blue-500 text-white rounded shadow">Shuffle</button>}
                    </div>
                </div>
            );
        };

        const Numpad = ({ value, setValue }) => {
            const append = (num) => setValue(prev => prev === '0' ? num : prev + num);
            const toggleSign = () => setValue(prev => prev.startsWith('-') ? prev.substring(1) : '-' + prev);
            const backspace = () => setValue(prev => prev.length > 1 ? prev.slice(0, -1) : '0');

            return (
                <div className="bg-slate-800 rounded-xl p-4 border border-slate-600 flex gap-4">
                    <div className="w-48">
                        <div className="bg-black/50 text-green-400 font-mono text-3xl p-2 rounded mb-2 text-right overflow-hidden">{value || '0'}</div>
                        <div className="grid grid-cols-3 gap-2">
                            {[7,8,9,4,5,6,1,2,3].map(num => (
                                <button key={num} onClick={() => append(num.toString())} className="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded font-bold transition-colors">{num}</button>
                            ))}
                            <button onClick={toggleSign} className="bg-slate-600 hover:bg-slate-500 text-white p-2 rounded">+/-</button>
                            <button onClick={() => append('0')} className="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded font-bold">0</button>
                            <button onClick={backspace} className="bg-red-900/50 hover:bg-red-900/80 text-white p-2 rounded">âŒ«</button>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            // --- Save System ---
            const [activeProfile, setActiveProfile] = useState(1);
            const [isSaveMenuOpen, setIsSaveMenuOpen] = useState(false);
            const [isLoaded, setIsLoaded] = useState(false);

            // --- Game State ---
            const [mainDeck, setMainDeck] = useState([]);
            const [graveyard, setGraveyard] = useState([]);
            
            const [playerHand, setPlayerHand] = useState([]);
            const [systemHand, setSystemHand] = useState([]);
            
            // Replaced single sets with distinct manual sets. Auto selection is now derived.
            const [manualPlayerIds, setManualPlayerIds] = useState(new Set());
            const [manualSystemIds, setManualSystemIds] = useState(new Set());
            
            const [jackValues, setJackValues] = useState({}); 

            const [encounterActive, setEncounterActive] = useState(false);
            const [manualMode, setManualMode] = useState(false);
            const [manualTargetValue, setManualTargetValue] = useState('0');
            const [conditionals, setConditionals] = useState({ x: 1, y: 0 });

            const [turnResult, setTurnResult] = useState(null);
            const [logs, setLogs] = useState([]);
            
            const [modal, setModal] = useState(null); 
            const [systemPendingCritFail, setSystemPendingCritFail] = useState(false);
            const [pendingPlayerDraw, setPendingPlayerDraw] = useState(false);
            
            const logEndRef = useRef(null);

            // --- Helpers for Selection Merging ---
            const getAutoSelectedIds = (hand, count) => {
                const s = new Set();
                const limit = Math.min(count, hand.length);
                for (let i = 0; i < limit; i++) s.add(hand[i].id);
                return s;
            };

            const getEffectiveSelectedIds = (hand, manualSet, autoCount) => {
                const combined = new Set(manualSet);
                const limit = Math.min(autoCount, hand.length);
                for (let i = 0; i < limit; i++) combined.add(hand[i].id);
                return combined;
            };

            // --- Initialization & Saving ---
            useEffect(() => {
                setIsLoaded(false);
                const saveKey = `card_game_save_${activeProfile}`;
                const savedData = localStorage.getItem(saveKey);
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        setMainDeck(uniqueDeck(data.mainDeck || []));
                        setGraveyard(uniqueDeck(data.graveyard || []));
                        setPlayerHand(uniqueDeck(data.playerHand || []));
                        setSystemHand(uniqueDeck(data.systemHand || []));
                        const loadedCond = data.conditionals || { x: 1, y: 0 };
                        setConditionals({ x: parseInt(loadedCond.x), y: parseInt(loadedCond.y) });
                        setLogs(data.logs || []);
                        setEncounterActive(data.encounterActive || false);
                        setManualMode(data.manualMode || false);
                        setManualTargetValue(data.manualTargetValue || '0');
                        setJackValues(data.jackValues || {});
                        setSystemPendingCritFail(data.systemPendingCritFail || false);
                        
                        // We reset manual selections on load for simplicity or could persist them. 
                        // For this refactor, let's clear them to ensure consistency with derived logic.
                        setManualPlayerIds(new Set());
                        setManualSystemIds(new Set());
                        
                        setTurnResult(null);
                        setLogs(prev => [...(data.logs || []), { id: Date.now() + Math.random(), text: `Profile ${activeProfile} Loaded.`, type: 'system' }]);
                        setPendingPlayerDraw(false);
                    } catch (e) { resetGame(false); }
                } else { resetGame(false); }
                setIsLoaded(true);
            }, [activeProfile]);

            useEffect(() => {
                if (!isLoaded) return;
                const gameState = {
                    mainDeck, graveyard, playerHand, systemHand, conditionals, logs, encounterActive, manualMode, manualTargetValue, jackValues, systemPendingCritFail,
                    timestamp: Date.now()
                };
                localStorage.setItem(`card_game_save_${activeProfile}`, JSON.stringify(gameState));
            }, [mainDeck, graveyard, playerHand, systemHand, conditionals, logs, encounterActive, manualMode, manualTargetValue, jackValues, systemPendingCritFail, activeProfile, isLoaded]);

            useEffect(() => { logEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [logs]);

            // --- Auto Actions (System) ---

            useEffect(() => {
                if (!encounterActive || manualMode) return;
                
                const blackAces = systemHand.filter(c => c.type === 'Ace' && c.color === 'black');
                const redAces = systemHand.filter(c => c.type === 'Ace' && c.color === 'red');

                if (blackAces.length > 0) {
                    log("System plays Black Ace! Refreshing System Hand.", 'danger');
                    recycleAndRefillHand('system', 'self'); 
                    return; 
                }
                if (redAces.length > 0) {
                    log("System plays Red Ace! Refreshing Player Hand.", 'danger');
                    recycleAndRefillHand('player', 'opponent');
                    return;
                }

            }, [systemHand, encounterActive, manualMode]);

            // --- Auto Actions (Y Lock Modal Triggers) ---
            useEffect(() => {
                if (!isLoaded) return;
                if (!encounterActive && !manualMode) return; 

                // Priority 1: System Auto-Selection (If Manual Mode active)
                if (manualMode) {
                    const sysLimit = Math.min(conditionals.y, systemHand.length);
                    for (let i = 0; i < sysLimit; i++) {
                        const c = systemHand[i];
                        if (c.type === 'Ace' && !modal) {
                            setModal({ type: 'ACE_AUTO', card: c, isSystem: true });
                            return;
                        }
                        if (c.type === 'Jack' && jackValues[c.id] === undefined && !modal) {
                            setModal({ type: 'JACK_AUTO', card: c, isRed: c.color === 'red', currentValue: c.color === 'red' ? -1 : 1, isSystem: true });
                            return;
                        }
                    }
                }

                // Priority 2: Player Auto-Selection
                const pLimit = Math.min(conditionals.y, playerHand.length);
                
                for(let i=0; i<pLimit; i++) {
                    const c = playerHand[i];
                    if (c.type === 'Ace' && !modal) {
                         setModal({ type: 'ACE_AUTO', card: c, isSystem: false });
                         return; 
                    }

                    if (c.type === 'Jack' && jackValues[c.id] === undefined && !modal) {
                         setModal({ type: 'JACK_AUTO', card: c, isRed: c.color === 'red', currentValue: c.color === 'red' ? -1 : 1, isSystem: false });
                         return;
                    }
                }
            }, [playerHand, systemHand, conditionals, manualMode, encounterActive, isLoaded, jackValues, modal]); 


            // --- Core Logic ---

            const log = (message, type = 'neutral') => setLogs(prev => [...prev, { id: Date.now() + Math.random(), text: message, type }]);

            const resetGame = (isStopEncounter = false) => {
                let deck = createDeck();
                deck = shuffleDeck(deck);
                const pHand = deck.slice(0, 5);
                const sHand = deck.slice(5, 10);
                const remainingDeck = deck.slice(10);
                setMainDeck(remainingDeck);
                setPlayerHand(pHand);
                setSystemHand(sHand);
                setGraveyard([]);
                setManualPlayerIds(new Set());
                setManualSystemIds(new Set());
                setJackValues({});
                setTurnResult(null);
                setSystemPendingCritFail(false);
                setModal(null);
                setPendingPlayerDraw(false);
                
                if (isStopEncounter) {
                    setEncounterActive(false);
                    log("Encounter stopped. Deck reset.", 'system');
                } else {
                    setLogs([{ id: Date.now() + Math.random(), text: "Welcome. Press 'Start Enc.' to begin.", type: 'system' }]);
                }
            };

            const toggleEncounter = () => {
                if (encounterActive) resetGame(true);
                else {
                    setEncounterActive(true);
                    setTurnResult(null);
                    setLogs([]);
                    log("Encounter Started!", 'success');
                }
            };

            const changeConditionals = (type, delta) => {
                setConditionals(prev => {
                    const next = { ...prev };
                    if (type === 'x') {
                        next.x = Math.max(1, Math.min(5, prev.x + delta));
                        // Ensure Y is not > X
                        if (next.y > next.x) next.y = next.x;
                    } else if (type === 'y') {
                        const potentialY = prev.y + delta;
                        
                        // Check if increasing Y violates total limit (X) given current manual selections
                        if (delta > 0) {
                            if (potentialY > prev.x) return prev; // Can't exceed X
                            
                            // Check Player Limit
                            // If we increase Y, we add 1 mandatory selection.
                            // If that overlap with existing manual, it effectively converts manual->auto (count stays same).
                            // If it DOESN'T overlap, count increases.
                            
                            // To be safe and explicit as requested: "prompt if too many selected cards".
                            // Simple check: If (newY + validManualCount) > X -> Block.
                            // Valid manual count excludes cards that will become auto.
                            
                            // Filter current manual sets to exclude cards that WOULD become auto
                            const pManualRemaining = new Set([...manualPlayerIds].filter(id => {
                                const idx = playerHand.findIndex(c => c.id === id);
                                return idx >= potentialY;
                            }));
                            
                            if (potentialY + pManualRemaining.size > prev.x) {
                                setModal({ type: 'LIMIT_REACHED', isSystem: false });
                                return prev;
                            }
                            
                            if (manualMode) {
                                const sManualRemaining = new Set([...manualSystemIds].filter(id => {
                                    const idx = systemHand.findIndex(c => c.id === id);
                                    return idx >= potentialY;
                                }));
                                if (potentialY + sManualRemaining.size > prev.x) {
                                    setModal({ type: 'LIMIT_REACHED', isSystem: true });
                                    return prev;
                                }
                            }
                            
                            // If allowed, we also need to cleanup the manual sets so we don't have duplicates
                            // This is done in the state update below, but here we just return the new value to update Y
                        }
                        
                        next.y = Math.max(0, Math.min(prev.x, potentialY));
                        
                        // Clean up manual sets if Y increases (swallowing manual cards)
                        if (next.y > prev.y) {
                             setManualPlayerIds(curr => {
                                 const n = new Set();
                                 curr.forEach(id => {
                                     const idx = playerHand.findIndex(c => c.id === id);
                                     if (idx >= next.y) n.add(id);
                                 });
                                 return n;
                             });
                             if (manualMode) {
                                 setManualSystemIds(curr => {
                                     const n = new Set();
                                     curr.forEach(id => {
                                         const idx = systemHand.findIndex(c => c.id === id);
                                         if (idx >= next.y) n.add(id);
                                     });
                                     return n;
                                 });
                             }
                        }
                    }
                    return next;
                });
            };

            const drawFromDeck = (deck, grave, count) => {
                let d = [...deck];
                let g = uniqueDeck([...grave]);
                let drawn = [];
                for(let i=0; i<count; i++) {
                    if (d.length === 0) {
                        if (g.length === 0) break;
                        d = shuffleDeck([...g]);
                        g = [];
                    }
                    drawn.push(d.pop());
                }
                return { drawn, deck: d, graveyard: g };
            };

            const recycleAndRefillHand = (target, source) => {
                let currentHand = target === 'player' ? playerHand : systemHand;
                let currentDeck = [...mainDeck];
                let currentGraveyard = [...graveyard];

                const cardsToDiscard = [...currentHand];
                currentGraveyard = uniqueDeck([...currentGraveyard, ...cardsToDiscard]);

                const res = drawFromDeck(currentDeck, currentGraveyard, 5);
                let newHand = res.drawn;

                if (target === 'system' && !manualMode) {
                     // Auto Logic for System only
                    let blackRoyaltyCount = newHand.filter(c => c.type === 'Royalty' && c.color === 'black').length;
                    let tempDeck = res.deck;
                    let tempGrav = res.graveyard;
                    while (blackRoyaltyCount > 1) {
                            const idx = newHand.findIndex(c => c.type === 'Royalty' && c.color === 'black');
                            const discarded = newHand.splice(idx, 1)[0];
                            tempGrav.push(discarded);
                            const drawRes = drawFromDeck(tempDeck, tempGrav, 1);
                            tempDeck = drawRes.deck;
                            tempGrav = drawRes.graveyard;
                            if (drawRes.drawn.length > 0) newHand.push(drawRes.drawn[0]);
                            blackRoyaltyCount = newHand.filter(c => c.type === 'Royalty' && c.color === 'black').length;
                    }
                    setMainDeck(tempDeck);
                    setGraveyard(tempGrav);
                } else {
                    setMainDeck(res.deck);
                    setGraveyard(res.graveyard);
                }

                if (target === 'player') {
                    setPlayerHand(newHand);
                    setManualPlayerIds(new Set()); 
                } else {
                    setSystemHand(newHand);
                    setManualSystemIds(new Set());
                }
            };

            const handleAceEffect = (card, source = 'player') => {
                setModal(null); 
                const isBlack = card.color === 'black';
                
                if (isBlack) {
                    if (source === 'player') {
                         log("Player Black Ace: Player Hand Discarded & Redrawn.", 'success');
                         recycleAndRefillHand('player', 'self');
                    } else {
                         log("System Black Ace: System Hand Discarded & Redrawn.", 'danger');
                         recycleAndRefillHand('system', 'self');
                    }
                } else {
                     if (source === 'player') {
                         log("Player Red Ace: System Hand Discarded & Redrawn.", 'success');
                         let newHand = playerHand.filter(c => c.id !== card.id);
                         let grav = uniqueDeck([...graveyard, card]);
                         let deck = [...mainDeck];
                         const res1 = drawFromDeck(deck, grav, 1);
                         newHand = uniqueDeck([...newHand, ...res1.drawn]);
                         
                         let sysDiscard = [...systemHand];
                         grav = uniqueDeck([...res1.graveyard, ...sysDiscard]);
                         const res2 = drawFromDeck(res1.deck, grav, 5);
                         
                         let sHand = res2.drawn;
                         let tDeck = res2.deck;
                         let tGrav = res2.graveyard;
                         
                         if (!manualMode) {
                              let blackRoyaltyCount = sHand.filter(c => c.type === 'Royalty' && c.color === 'black').length;
                                while (blackRoyaltyCount > 1) {
                                     const idx = sHand.findIndex(c => c.type === 'Royalty' && c.color === 'black');
                                     const discarded = sHand.splice(idx, 1)[0];
                                     tGrav.push(discarded);
                                     const dRes = drawFromDeck(tDeck, tGrav, 1);
                                     tDeck = dRes.deck;
                                     tGrav = dRes.graveyard;
                                     if (dRes.drawn.length > 0) sHand.push(dRes.drawn[0]);
                                     blackRoyaltyCount = sHand.filter(c => c.type === 'Royalty' && c.color === 'black').length;
                                }
                         }

                         setPlayerHand(newHand);
                         setSystemHand(sHand);
                         setGraveyard(tGrav);
                         setMainDeck(tDeck);
                         setManualPlayerIds(new Set());

                     } else {
                         log("System Red Ace: Player Hand Discarded & Redrawn.", 'danger');
                         let newSysHand = systemHand.filter(c => c.id !== card.id);
                         let grav = uniqueDeck([...graveyard, card]);
                         let deck = [...mainDeck];
                         
                         const res1 = drawFromDeck(deck, grav, 1);
                         newSysHand = uniqueDeck([...newSysHand, ...res1.drawn]);
                         
                         let playerDiscard = [...playerHand];
                         grav = uniqueDeck([...res1.graveyard, ...playerDiscard]);
                         
                         const res2 = drawFromDeck(res1.deck, grav, 5);
                         
                         setSystemHand(newSysHand);
                         setPlayerHand(res2.drawn);
                         setGraveyard(res2.graveyard);
                         setMainDeck(res2.deck);
                         setManualSystemIds(new Set());
                         setManualPlayerIds(new Set());
                     }
                }
            };

            const handleCardSelect = (card, isPlayer) => {
                const canAct = encounterActive || (manualMode && !encounterActive);
                if (!canAct) return;
                if (!isPlayer && !manualMode) return; 

                // Priority 1: Ace Check
                if (card.type === 'Ace') {
                    setModal({ type: 'ACE_MANUAL', card, isSystem: !isPlayer });
                    return; 
                }

                // Priority 2: Locked check
                const hand = isPlayer ? playerHand : systemHand;
                const index = hand.findIndex(c => c.id === card.id);
                if (index < conditionals.y) return; // Locked by auto-selection

                const currentManualSet = isPlayer ? manualPlayerIds : manualSystemIds;
                const setFunction = isPlayer ? setManualPlayerIds : setManualSystemIds;

                // Jack Logic (Toggle)
                if (card.type === 'Jack') {
                    if (currentManualSet.has(card.id)) {
                        setFunction(prev => {
                            const newSet = new Set(prev);
                            newSet.delete(card.id);
                            return newSet;
                        });
                        return;
                    }
                    setModal({
                        type: 'JACK',
                        cardId: card.id,
                        isRed: card.color === 'red',
                        currentValue: jackValues[card.id] || (card.color === 'red' ? -1 : 1),
                        isSystem: !isPlayer
                    });
                    return;
                }

                setFunction(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(card.id)) {
                        newSet.delete(card.id);
                    } else {
                        // Check limit: Manual + Auto <= X
                        if (newSet.size + conditionals.y < conditionals.x) {
                            newSet.add(card.id);
                        } else {
                             log("Limit Reached. Deselect a card first.", 'neutral');
                        }
                    }
                    return newSet;
                });
            };

            const confirmJackValue = (cardId, val) => {
                setJackValues(prev => ({ ...prev, [cardId]: val }));
                const isSystem = modal?.isSystem;
                setModal(null);
                
                const setFunction = isSystem ? setManualSystemIds : setManualPlayerIds;
                const currentSet = isSystem ? manualSystemIds : manualPlayerIds;
                
                setFunction(prev => {
                    if (prev.size + conditionals.y < conditionals.x) return new Set(prev).add(cardId);
                    log(`${isSystem?'System':'Player'} Jack value set. Limit reached, not selected.`, 'neutral');
                    return prev;
                });
            };

            // Extracted logic to fill player hand
            const performPlayerDraw = (currentDeck, currentGraveyard) => {
                const pSelected = getEffectiveSelectedIds(playerHand, manualPlayerIds, conditionals.y);
                let nextPHand = playerHand.filter(c => !pSelected.has(c.id));
                const playNeeded = 5 - nextPHand.length;
                let drawnForPlayer = [];
                let playerConflict = null; 
                let playerInstantFail = false;
                
                let tempDeck = [...currentDeck];
                let tempGrav = [...currentGraveyard];

                const drawOne = () => {
                    if (tempDeck.length === 0) {
                        if (tempGrav.length === 0) return null;
                        tempDeck = shuffleDeck([...tempGrav]);
                        tempGrav = [];
                    }
                    return tempDeck.pop();
                }

                for(let i=0; i<playNeeded; i++) {
                    const c = drawOne();
                    if (c) {
                        if (c.type === 'Royalty' && c.color === 'red') {
                             if (nextPHand.some(h => h.type === 'Royalty' && h.color === 'red') || drawnForPlayer.some(h => h.type === 'Royalty' && h.color === 'red')) {
                                 playerInstantFail = true;
                             }
                        }
                        if (c.type === 'Royalty' && c.color === 'black') {
                             const existing = nextPHand.find(h => h.type === 'Royalty' && h.color === 'black') || drawnForPlayer.find(h => h.type === 'Royalty' && h.color === 'black');
                             if (existing) {
                                 playerConflict = { newCard: c, oldCard: existing };
                             }
                        }
                        drawnForPlayer.push(c);
                    }
                }

                if (playerInstantFail) {
                    log("You drew a duplicate Red Royalty! INSTANT DEFEAT.", 'danger');
                    setTurnResult({ winner: 'system', detail: "Instant Defeat: Duplicate Red Royalty", playerScore: -1, systemScore: 0, pCards:[], sCards:[] });
                    setEncounterActive(false); 
                }

                setGraveyard(uniqueDeck(tempGrav));
                setMainDeck(uniqueDeck(tempDeck));
                setPendingPlayerDraw(false);
                setManualPlayerIds(new Set());
                
                if (playerConflict) {
                    setPlayerHand(uniqueDeck([...nextPHand, ...drawnForPlayer]));
                    setModal({
                        type: 'ROYALTY_CONFLICT',
                        newCard: playerConflict.newCard,
                        oldCard: playerConflict.oldCard,
                        isSystem: false
                    });
                } else {
                    setPlayerHand(uniqueDeck([...nextPHand, ...drawnForPlayer]));
                }
            };

            const endTurn = () => {
                const pSelected = getEffectiveSelectedIds(playerHand, manualPlayerIds, conditionals.y);
                const sSelected = getEffectiveSelectedIds(systemHand, manualSystemIds, manualMode ? conditionals.y : conditionals.x);

                if (pSelected.size !== conditionals.x) {
                    log(`Error: Selected ${pSelected.size}/${conditionals.x} cards (Auto: ${conditionals.y}).`, 'danger');
                    return;
                }

                const pCards = playerHand.filter(c => pSelected.has(c.id));
                const sCards = systemHand.filter(c => sSelected.has(c.id));
                
                // If System isn't Manual, sSelected might already be autosliced, but filter ensures safety.

                // --- Number Check Mode ---
                if (manualMode && !encounterActive) {
                    const pRes = calculateHandScore(pCards, jackValues);
                    const target = parseInt(manualTargetValue);
                    
                    let winner = 'draw', detail = '';
                    if (pRes.score === 0 || pRes.hasBlackRoyalty) { winner='player'; detail="Critical Success (0)!"; }
                    else if (pRes.score === -1) { winner='system'; detail="Critical Failure (-1)!"; } 
                    else {
                        if (pRes.score >= 0 && target < 0) { winner='player'; detail="Positive beats Negative."; }
                        else if (target >= 0 && pRes.score < 0) { winner='system'; detail="Positive beats Negative."; }
                        else if (pRes.score >= 0 && target >= 0) {
                            if (pRes.score < target) { winner='player'; detail=`Success! ${pRes.score} vs ${target}`; }
                            else if (target < pRes.score) { winner='system'; detail=`Fail. ${pRes.score} vs ${target}`; }
                            else detail=`Tie. ${pRes.score} vs ${target}`;
                        } else {
                            if (pRes.score > target) { winner='player'; detail=`Success! ${pRes.score} vs ${target} (Lower Neg Wins)`; }
                            else if (target > pRes.score) { winner='system'; detail=`Fail. ${pRes.score} vs ${target} (Lower Neg Wins)`; }
                            else detail=`Tie. ${pRes.score} vs ${target}`;
                        }
                    }
                    
                    setTurnResult({ winner, playerScore: pRes.score, systemScore: target, pCards, sCards: [], detail, isNumberCheck: true });
                    log(`Check: ${pRes.score} vs ${target}. ${detail}`, winner === 'player' ? 'success' : 'danger');
                    
                    let deck = [...pCards, ...mainDeck];
                    let newHand = playerHand.filter(c => !pSelected.has(c.id));
                    while(newHand.length < 5 && deck.length > 0) newHand.push(deck.pop());
                    setMainDeck(uniqueDeck(deck));
                    setPlayerHand(uniqueDeck(newHand));
                    setManualPlayerIds(new Set());
                    return;
                }

                if (!encounterActive) return;

                const pRes = calculateHandScore(pCards, jackValues);
                const sRes = calculateHandScore(sCards, jackValues, true); // System scores

                let pScore = pRes.score;
                let sScore = sRes.score;
                
                let pFinal = pRes.hasBlackRoyalty ? 0 : pScore;
                let sFinal = sRes.hasBlackRoyalty ? 0 : sScore;
                
                if (pRes.hasRedRoyalty) sFinal = -1; 
                if (sRes.hasRedRoyalty) pFinal = -1; 
                
                if (pRes.hasBlackRoyalty || pRes.hasRedRoyalty) log(`Player uses ${pRes.hasBlackRoyalty ? 'Black' : 'Red'} Royalty!`, 'system');
                if (sRes.hasBlackRoyalty || sRes.hasRedRoyalty) log(`System uses ${sRes.hasBlackRoyalty ? 'Black' : 'Red'} Royalty!`, 'system');

                let winner = null;
                let detail = "";
                
                const pFail = pFinal === -1;
                const sFail = sFinal === -1;
                const pCrit = pFinal === 0;
                const sCrit = sFinal === 0;

                if (systemPendingCritFail) {
                    sFinal = -1; 
                    detail = "System suffered Critical Failure from Duplicate Red Royalty!";
                    winner = 'player';
                } else if (pFail && sFail) { winner='draw'; detail="Double Failure!"; }
                else if (pFail) { winner='system'; detail="Player Critical Failure!"; }
                else if (sFail) { winner='player'; detail="System Critical Failure!"; }
                else if (pCrit && sCrit) { winner='draw'; detail="Double Critical Success!"; }
                else if (pCrit) { winner='player'; detail="Player Critical Success!"; }
                else if (sCrit) { winner='system'; detail="System Critical Success!"; }
                else {
                    if (pFinal >= 0 && sFinal < 0) { winner='player'; detail="Player Positive vs System Negative."; }
                    else if (sFinal >= 0 && pFinal < 0) { winner='system'; detail="System Positive vs Player Negative."; }
                    else if (pFinal >= 0 && sFinal >= 0) {
                        if (pFinal < sFinal) { winner='player'; detail=`Player closer to 0.`; }
                        else if (sFinal < pFinal) { winner='system'; detail=`System closer to 0.`; }
                        else { winner='draw'; detail="Tie."; }
                    } else {
                        if (pFinal > sFinal) { winner='player'; detail=`Player closer to 0 (Lower Neg).`; }
                        else if (sFinal > pFinal) { winner='system'; detail=`System closer to 0 (Lower Neg).`; }
                        else { winner='draw'; detail="Tie."; }
                    }
                }

                setTurnResult({ winner, playerScore: pFinal, systemScore: sFinal, pCards, sCards, detail });
                log(`Result: P(${pFinal}) vs S(${sFinal}). ${detail}`, winner === 'player' ? 'success' : winner === 'system' ? 'danger' : 'neutral');
                if (systemPendingCritFail) setSystemPendingCritFail(false); 

                const discard = [...pCards, ...sCards];
                const newGrav = uniqueDeck([...graveyard, ...discard]);
                
                let nextSHand = systemHand.filter(c => !sSelected.has(c.id));
                
                let tempDeck = [...mainDeck];
                let tempGrav = [...newGrav];
                
                const drawOne = () => {
                    if (tempDeck.length === 0) {
                        if (tempGrav.length === 0) return null;
                        tempDeck = shuffleDeck([...tempGrav]);
                        tempGrav = [];
                    }
                    return tempDeck.pop();
                }

                const sysNeeded = 5 - nextSHand.length;
                let sysConflict = null;

                for(let i=0; i<sysNeeded; i++) {
                    const c = drawOne();
                    if(c) {
                        if (c.type === 'Royalty' && c.color === 'red') {
                            if (nextSHand.some(h => h.type === 'Royalty' && h.color === 'red')) {
                                log("System drew duplicate Red Royalty! Pending Failure.", 'danger');
                                setSystemPendingCritFail(true);
                            }
                        }
                        
                        if (c.type === 'Royalty' && c.color === 'black') {
                            const existing = nextSHand.find(h => h.type === 'Royalty' && h.color === 'black');
                            if (existing) {
                                if (manualMode) {
                                    sysConflict = { newCard: c, oldCard: existing };
                                } else {
                                    tempGrav.push(c);
                                    i--; 
                                    continue;
                                }
                            }
                        }
                        nextSHand.push(c);
                    }
                }

                setSystemHand(uniqueDeck(nextSHand));
                setManualSystemIds(new Set());
                
                if (sysConflict && manualMode) {
                     setGraveyard(uniqueDeck(tempGrav));
                     setMainDeck(uniqueDeck(tempDeck));
                     setModal({
                        type: 'ROYALTY_CONFLICT',
                        newCard: sysConflict.newCard,
                        oldCard: sysConflict.oldCard,
                        isSystem: true
                     });
                     setPendingPlayerDraw(true); 
                     return; 
                }

                performPlayerDraw(tempDeck, tempGrav);
            };

            const resolveRoyaltyConflict = (keepNew) => {
                if (!modal || modal.type !== 'ROYALTY_CONFLICT') return;
                const { newCard, oldCard, isSystem } = modal;
                const discard = keepNew ? oldCard : newCard;
                
                let targetHand = isSystem ? systemHand : playerHand;
                let newHand = targetHand.filter(c => c.id !== discard.id);
                
                let grav = uniqueDeck([...graveyard, discard]);
                let deck = [...mainDeck];
                
                const res = drawFromDeck(deck, grav, 1);
                newHand = [...newHand, ...res.drawn];

                if (isSystem) setSystemHand(uniqueDeck(newHand));
                else setPlayerHand(uniqueDeck(newHand));
                
                setGraveyard(res.graveyard);
                setMainDeck(res.deck);

                log(`${isSystem?'System':'Player'} Resolved Conflict. Discarded ${discard.label}${discard.suit}.`, isSystem ? 'danger' : 'system');
                setModal(null);
            };
            
            useEffect(() => {
                if (pendingPlayerDraw && !modal) {
                     performPlayerDraw(mainDeck, graveyard);
                }
            }, [pendingPlayerDraw, modal]); 

            // Visibility Logic
            const showPlayerHand = encounterActive || manualMode;
            
            let numpadClass = "";
            if (!manualMode) {
                numpadClass = "-translate-y-24 opacity-0 pointer-events-none"; 
            } else if (encounterActive) {
                numpadClass = "-translate-x-[120%] opacity-0 pointer-events-none"; 
            } else {
                numpadClass = "translate-x-0 translate-y-0 opacity-100 z-10"; 
            }

            let sysHandClass = "";
            if (encounterActive) {
                sysHandClass = "translate-x-0 translate-y-0 opacity-100 z-10"; 
            } else if (manualMode) {
                sysHandClass = "translate-x-[120%] opacity-0 pointer-events-none"; 
            } else {
                sysHandClass = "-translate-y-24 opacity-0 pointer-events-none"; 
            }

            const pSelectedForRender = getEffectiveSelectedIds(playerHand, manualPlayerIds, conditionals.y);
            const sSelectedForRender = getEffectiveSelectedIds(systemHand, manualSystemIds, manualMode ? conditionals.y : 0);

            return (
                <div className="min-h-screen wood-texture flex flex-col items-center justify-center p-4 font-sans text-slate-100">
                    <style>{styles}</style>

                    {/* --- MODALS --- */}
                    {modal?.type === 'LIMIT_REACHED' && (
                        <Modal>
                            <h3 className="text-xl font-bold mb-4 text-center text-red-500">Limit Reached</h3>
                            <p className="mb-6 text-center text-sm text-slate-300">
                                {modal.isSystem ? 'System' : 'Player'} has too many cards selected. 
                                <br/>Please deselect manual cards before increasing the Auto-Lock limit.
                            </p>
                            <button onClick={() => setModal(null)} className="w-full bg-slate-600 py-2 rounded font-bold hover:bg-slate-500">OK</button>
                        </Modal>
                    )}

                    {modal?.type === 'JACK' && (
                        <Modal>
                            <h3 className={`text-xl font-bold mb-4 text-center ${modal.isSystem ? 'text-red-500' : 'text-white'}`}>{modal.isSystem ? 'System ' : ''}Set Jack Value</h3>
                            <div className="flex items-center justify-center gap-4 mb-6">
                                <button onClick={() => setModal(p => ({...p, currentValue: modal.isRed ? Math.max(-5, p.currentValue - 1) : Math.max(1, p.currentValue - 1) }))} className="bg-slate-700 w-10 h-10 rounded font-bold text-xl">-</button>
                                <span className="text-4xl font-mono">{modal.currentValue}</span>
                                <button onClick={() => setModal(p => ({...p, currentValue: modal.isRed ? Math.min(-1, p.currentValue + 1) : Math.min(5, p.currentValue + 1) }))} className="bg-slate-700 w-10 h-10 rounded font-bold text-xl">+</button>
                            </div>
                            <button onClick={() => confirmJackValue(modal.cardId, modal.currentValue)} className="w-full bg-green-600 py-2 rounded font-bold">Confirm</button>
                        </Modal>
                    )}
                    
                    {modal?.type === 'JACK_AUTO' && (
                        <Modal>
                            <h3 className={`text-xl font-bold mb-4 text-center ${modal.isSystem ? 'text-red-500' : 'text-yellow-400'}`}>{modal.isSystem ? 'System ' : ''}Jack Auto-Selected!</h3>
                            <p className="mb-4 text-center text-sm text-slate-300">This Jack was selected by the Auto (Y) limit. Please set its value.</p>
                            <div className="flex items-center justify-center gap-4 mb-6">
                                <button onClick={() => setModal(p => ({...p, currentValue: modal.isRed ? Math.max(-5, p.currentValue - 1) : Math.max(1, p.currentValue - 1) }))} className="bg-slate-700 w-10 h-10 rounded font-bold text-xl">-</button>
                                <span className="text-4xl font-mono">{modal.currentValue}</span>
                                <button onClick={() => setModal(p => ({...p, currentValue: modal.isRed ? Math.min(-1, p.currentValue + 1) : Math.min(5, p.currentValue + 1) }))} className="bg-slate-700 w-10 h-10 rounded font-bold text-xl">+</button>
                            </div>
                            <button onClick={() => confirmJackValue(modal.card.id, modal.currentValue)} className="w-full bg-green-600 py-2 rounded font-bold">Confirm & Continue</button>
                        </Modal>
                    )}

                    {modal?.type === 'ACE_AUTO' && (
                        <Modal>
                            <h3 className={`text-xl font-bold mb-4 text-center ${modal.isSystem ? 'text-red-500' : 'text-yellow-400'}`}>{modal.isSystem ? 'System ' : ''}Ace Auto-Selected!</h3>
                            <p className="mb-6 text-center text-sm text-slate-300">
                                This Ace was selected by the Auto (Y) limit. 
                                <br/><span className="font-bold text-white">{modal.card.color === 'black' ? `Play Black Ace to refresh ${modal.isSystem?'SYSTEM':'YOUR'} hand?` : `Play Red Ace to refresh ${modal.isSystem?'YOUR':'SYSTEM'} hand?`}</span>
                            </p>
                            <button onClick={() => handleAceEffect(modal.card, modal.isSystem ? 'system' : 'player')} className="w-full bg-green-600 py-3 rounded font-bold text-lg mb-2">Confirm Play</button>
                        </Modal>
                    )}

                    {modal?.type === 'ACE_MANUAL' && (
                         <Modal>
                            <h3 className={`text-xl font-bold mb-4 text-center ${modal.isSystem ? 'text-red-500' : 'text-white'}`}>Play {modal.isSystem ? 'System' : ''} Ace Manually?</h3>
                            <div className="flex flex-col items-center gap-4">
                                <div className="text-4xl">{modal.card.color === 'black' ? 'â™ /â™£' : 'â™¥/â™¦'}</div>
                                <p className="text-center text-sm text-slate-300 mb-2">
                                    {modal.card.color === 'black' 
                                        ? `This will discard the ${modal.isSystem?'SYSTEM':'PLAYER'} hand and draw 5 new cards.` 
                                        : `This will discard this card, redraw 1, then discard and redraw the ${modal.isSystem?'PLAYER':'SYSTEM'} hand.`}
                                </p>
                                <div className="flex gap-4 w-full">
                                    <button onClick={() => setModal(null)} className="flex-1 bg-slate-600 py-2 rounded font-bold hover:bg-slate-500">Cancel</button>
                                    <button onClick={() => handleAceEffect(modal.card, modal.isSystem ? 'system' : 'player')} className="flex-1 bg-green-600 py-2 rounded font-bold hover:bg-green-500">Confirm</button>
                                </div>
                            </div>
                        </Modal>
                    )}

                    {modal?.type === 'ROYALTY_CONFLICT' && (
                        <Modal>
                            <h3 className={`text-xl font-bold mb-4 text-center ${modal.isSystem ? 'text-red-500' : 'text-red-400'}`}>{modal.isSystem ? 'System ' : ''}Royalty Conflict!</h3>
                            <p className="mb-6 text-center text-sm text-slate-300">Only one Black Royalty allowed. Choose which to keep:</p>
                            <div className="flex gap-4">
                                <button onClick={() => resolveRoyaltyConflict(false)} className="flex-1 bg-slate-700 p-4 rounded border hover:bg-slate-600">
                                    <div className="text-xs uppercase text-slate-400">Keep Old</div>
                                    <div className="text-xl font-bold">{modal.oldCard.label} {modal.oldCard.suit}</div>
                                </button>
                                <button onClick={() => resolveRoyaltyConflict(true)} className="flex-1 bg-slate-700 p-4 rounded border hover:bg-slate-600">
                                    <div className="text-xs uppercase text-slate-400">Keep New</div>
                                    <div className="text-xl font-bold">{modal.newCard.label} {modal.newCard.suit}</div>
                                </button>
                            </div>
                        </Modal>
                    )}

                    {/* UI */}
                    <div className="absolute top-4 left-4 bg-slate-900/90 border border-slate-600 p-4 rounded-lg shadow-xl z-20">
                        <h3 className="text-white font-bold text-sm uppercase tracking-wider mb-3 border-b border-slate-700 pb-2">Conditionals</h3>
                        <div className="flex flex-col gap-3 text-sm">
                            <div className="flex justify-between items-center gap-4">
                                <span>Total Selected Cards:</span>
                                <div className="flex items-center gap-2">
                                    <button onClick={() => changeConditionals('x', -1)} className="bg-slate-700 px-2 rounded">-</button>
                                    <span className="w-4 text-center">{conditionals.x}</span>
                                    <button onClick={() => changeConditionals('x', 1)} className="bg-slate-700 px-2 rounded">+</button>
                                </div>
                            </div>
                            <div className="flex justify-between items-center gap-4">
                                <span>Total Auto-Locked Cards:</span>
                                <div className="flex items-center gap-2">
                                    <button onClick={() => changeConditionals('y', -1)} className="bg-slate-700 px-2 rounded">-</button>
                                    <span className="w-4 text-center">{conditionals.y}</span>
                                    <button onClick={() => changeConditionals('y', 1)} className="bg-slate-700 px-2 rounded">+</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="absolute bottom-4 right-4 z-30 flex flex-col items-end">
                        {isSaveMenuOpen && (
                            <div className="mb-2 bg-slate-900/95 border border-slate-600 rounded-lg p-2 shadow-2xl w-64 animate-in slide-in-from-bottom-2 fade-in">
                                {[1,2,3].map(id => (
                                    <div key={id} className={`flex justify-between p-2 rounded ${activeProfile===id?'bg-slate-700 ring-1 ring-blue-500':'bg-slate-800/50'}`}>
                                        <button onClick={() => setActiveProfile(id)} className="text-left font-bold w-full">Profile {id}</button>
                                        <button onClick={(e) => { e.stopPropagation(); if(confirm('Delete?')) localStorage.removeItem(`card_game_save_${id}`); }} className="text-red-400 ml-2">ðŸ—‘ï¸</button>
                                    </div>
                                ))}
                            </div>
                        )}
                        <button onClick={() => setIsSaveMenuOpen(!isSaveMenuOpen)} className="bg-blue-600 px-4 py-2 rounded-lg font-bold">Profile {activeProfile}</button>
                    </div>

                    <div className="w-full max-w-6xl flex flex-col gap-4 relative">
                        {/* System */}
                        <div className="w-full flex justify-center mb-4 min-h-[300px] relative overflow-hidden">
                             {/* Numpad Container */}
                             <div className={`absolute top-4 w-full flex justify-center transition-all duration-700 ease-in-out transform ${numpadClass}`}>
                                <Numpad value={manualTargetValue} setValue={setManualTargetValue} />
                             </div>

                             {/* System Hand Container */}
                             <div className={`absolute bottom-4 w-full flex justify-center transition-all duration-700 ease-in-out transform ${sysHandClass}`}>
                                <div className="flex gap-4 p-4 bg-black/20 rounded-xl backdrop-blur-sm border border-white/10">
                                    {systemHand.map((card, idx) => (
                                        <Card key={card.id} card={card} isFaceUp={encounterActive && manualMode} isSelected={sSelectedForRender.has(card.id)} onClick={() => handleCardSelect(card, false)} canSelect={manualMode && encounterActive} />
                                    ))}
                                    {systemHand.length === 0 && <div className="text-white/50 italic">System Hand Empty</div>}
                                </div>
                             </div>
                        </div>

                        {/* Middle */}
                        <div className="flex flex-col md:flex-row gap-6 justify-between items-stretch h-96 z-10">
                            <div className="w-full md:w-1/4 flex justify-center items-center bg-black/30 rounded-xl border border-white/5 felt-texture"><DeckPile label="Graveyard" count={graveyard.length} /></div>
                            <div className="w-full md:w-2/4 flex flex-col gap-4">
                                <div className="flex-1 bg-slate-900/90 rounded-xl border border-yellow-500/30 p-4 flex flex-col items-center justify-center shadow-2xl">
                                    {turnResult ? (
                                        <div className="text-center animate-in zoom-in w-full">
                                            <h2 className={`text-3xl font-bold mb-4 ${turnResult.winner==='player'?'text-green-400':turnResult.winner==='system'?'text-red-400':'text-yellow-400'}`}>{turnResult.winner==='player'?'VICTORY':turnResult.winner==='system'?'DEFEAT':'DRAW'}</h2>
                                            
                                            <div className="flex justify-between items-center px-4 w-full">
                                                {/* Player Side */}
                                                <div className="flex flex-col items-center gap-2">
                                                    <div className="text-xs uppercase tracking-widest text-slate-400">Player</div>
                                                    <div className="text-4xl font-bold font-mono">{turnResult.playerScore}</div>
                                                    <div className="flex gap-1 mt-1">
                                                        {turnResult.pCards.map(c => <Card key={`p-${c.id}`} card={c} isSmall isFaceUp />)}
                                                    </div>
                                                </div>

                                                <div className="text-xl font-bold text-slate-600">VS</div>

                                                {/* System Side */}
                                                <div className="flex flex-col items-center gap-2">
                                                    <div className="text-xs uppercase tracking-widest text-slate-400">{turnResult.isNumberCheck ? 'Target' : 'System'}</div>
                                                    <div className="text-4xl font-bold font-mono">{turnResult.systemScore}</div>
                                                    {!turnResult.isNumberCheck && (
                                                        <div className="flex gap-1 mt-1">
                                                            {turnResult.sCards.map(c => <Card key={`s-${c.id}`} card={c} isSmall isFaceUp />)}
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                            <p className="text-sm text-yellow-100/80 mt-4">{turnResult.detail}</p>
                                        </div>
                                    ) : (
                                        <div className="text-center text-white/40"><div className="text-6xl mb-2 opacity-20">â™ </div><p>{encounterActive ? "Select & End Turn" : manualMode ? "Check Mode" : "Start Encounter"}</p></div>
                                    )}
                                </div>
                                <div className="h-16 flex gap-2">
                                    <button onClick={() => setManualMode(!manualMode)} className="w-24 bg-purple-700 rounded-lg font-bold text-xs">{manualMode?'MANUAL ON':'MANUAL OFF'}</button>
                                    <button onClick={toggleEncounter} className={`flex-1 font-bold rounded-lg ${encounterActive?'bg-red-600':'bg-green-600'}`}>{encounterActive?'STOP':'START'}</button>
                                    <button onClick={endTurn} className="flex-1 bg-yellow-600 font-bold rounded-lg">END TURN</button>
                                </div>
                                <div className="h-32 bg-black/60 rounded-xl p-3 overflow-y-auto font-mono text-xs scrollbar-hide border border-white/10">
                                    {logs.map(log => <div key={log.id} className={log.type==='danger'?'text-red-400':log.type==='success'?'text-green-400':'text-gray-300'}>{log.text}</div>)}
                                    <div ref={logEndRef} />
                                </div>
                            </div>
                            <div className="w-full md:w-1/4 flex justify-center items-center bg-black/30 rounded-xl border border-white/5 felt-texture"><DeckPile label="Draw Deck" count={mainDeck.length} showShuffle onClick={() => { setMainDeck(shuffleDeck([...mainDeck])); log("Shuffled."); }} /></div>
                        </div>

                        {/* Player Hand */}
                        <div className="w-full flex justify-center mt-4 min-h-[160px] relative overflow-hidden">
                            <div className={`w-full flex justify-center transition-all duration-700 ease-in-out transform ${showPlayerHand ? 'translate-y-0 opacity-100' : 'translate-y-24 opacity-0 pointer-events-none'}`}>
                                <div className="flex gap-4 p-4 rounded-xl backdrop-blur-sm bg-black/40 border-transparent">
                                    {playerHand.map((card, idx) => (
                                        <Card 
                                            key={card.id} card={card} 
                                            isSelected={pSelectedForRender.has(card.id)} 
                                            isLocked={idx < conditionals.y} 
                                            onClick={() => handleCardSelect(card, true)} 
                                            customValue={jackValues[card.id]}
                                        />
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>